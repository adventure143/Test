<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Realistic Ramadan Celebration</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #canvas-container { position: absolute; width: 100%; height: 100%; }
        #loading-screen {
            position: absolute; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white;
            z-index: 1000; transition: opacity 1s;
        }
        .progress-bar {
            width: 300px; height: 3px; background: #333; margin: 20px 0;
        }
        #progress-fill { height: 100%; width: 0%; background: #FFD700; transition: width 0.3s; }
        #loading-text { margin-top: 20px; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="loading-screen">
        <h1>RAMADAN MUBARAK</h1>
        <div class="progress-bar"><div id="progress-fill"></div></div>
        <div id="loading-text">Initializing scene...</div>
    </div>

    <!-- Three.js and necessary extensions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a1a2e, 0.001);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.set(15, 10, 25);
        
        // Renderer with advanced settings
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Post-processing for realism
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, 0.4, 0.85
        );
        composer.addPass(bloomPass);
        
        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        
        // Update loading progress
        function updateProgress(percent, text) {
            document.getElementById('progress-fill').style.width = `${percent}%`;
            document.getElementById('loading-text').textContent = text;
        }
        
        updateProgress(10, "Setting up lighting...");
        
        // Lighting - critical for realism
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        scene.add(ambientLight);
        
        // Moon light (main directional light)
        const moonLight = new THREE.DirectionalLight(0xfff9e6, 0.8);
        moonLight.position.set(-10, 10, -10);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 2048;
        moonLight.shadow.mapSize.height = 2048;
        moonLight.shadow.camera.near = 0.5;
        moonLight.shadow.camera.far = 500;
        moonLight.shadow.bias = -0.001;
        scene.add(moonLight);
        
        // Fill light
        const fillLight = new THREE.DirectionalLight(0x667788, 0.2);
        fillLight.position.set(10, 5, 10);
        scene.add(fillLight);
        
        updateProgress(20, "Creating environment...");
        
        // Realistic moon
        const moonGeometry = new THREE.SphereGeometry(3, 64, 64);
        const moonMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffdd,
            emissive: 0xffffaa,
            emissiveIntensity: 0.3,
            roughness: 0.8,
            metalness: 0.1
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(-30, 25, -50);
        scene.add(moon);
        
        // Stars
        const starsGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            starVertices.push(
                (Math.random() - 0.5) * 2000,
                (Math.random() - 0.5) * 2000,
                (Math.random() - 0.5) * 2000
            );
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
        
        updateProgress(30, "Building mosque...");
        
        // Detailed mosque construction
        function createMosque() {
            const mosque = new THREE.Group();
            
            // Base platform
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(15, 0.5, 15),
                new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 })
            );
            base.position.y = -0.25;
            base.receiveShadow = true;
            mosque.add(base);
            
            // Main structure
            const walls = new THREE.Mesh(
                new THREE.BoxGeometry(12, 8, 12),
                new THREE.MeshStandardMaterial({ color: 0xE6D5B8, roughness: 0.6 })
            );
            walls.position.y = 4;
            walls.castShadow = true;
            walls.receiveShadow = true;
            mosque.add(walls);
            
            // Dome
            const dome = new THREE.Mesh(
                new THREE.SphereGeometry(5, 32, 32, 0, Math.PI * 2, 0, Math.PI/2),
                new THREE.MeshStandardMaterial({ 
                    color: 0xF0E68C,
                    roughness: 0.4,
                    metalness: 0.2
                })
            );
            dome.position.y = 12.5;
            dome.rotation.x = Math.PI;
            dome.castShadow = true;
            mosque.add(dome);
            
            // Dome finial
            const finial = new THREE.Mesh(
                new THREE.ConeGeometry(0.8, 2, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    metalness: 0.9,
                    roughness: 0.3
                })
            );
            finial.position.y = 15.5;
            mosque.add(finial);
            
            // Minarets
            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI/2;
                const x = Math.cos(angle) * 9;
                const z = Math.sin(angle) * 9;
                
                const minaret = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 1, 15, 16),
                    new THREE.MeshStandardMaterial({ color: 0xE6D5B8 })
                );
                minaret.position.set(x, 7.5, z);
                minaret.castShadow = true;
                mosque.add(minaret);
                
                const minaretTop = new THREE.Mesh(
                    new THREE.ConeGeometry(1, 3, 16),
                    new THREE.MeshStandardMaterial({ color: 0xF0E68C })
                );
                minaretTop.position.set(x, 16, z);
                mosque.add(minaretTop);
            }
            
            return mosque;
        }
        
        scene.add(createMosque());
        
        updateProgress(50, "Creating decorations...");
        
        // Lanterns with realistic lighting
        function createLantern(x, y, z) {
            const lantern = new THREE.Group();
            
            // Glass body
            const glass = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 0.6, 1.5, 16),
                new THREE.MeshPhysicalMaterial({
                    color: 0xFFD700,
                    transmission: 0.7,
                    roughness: 0.1,
                    metalness: 0.8,
                    clearcoat: 0.5,
                    ior: 1.5,
                    thickness: 0.1,
                    transparent: true
                })
            );
            glass.position.y = 0.75;
            glass.castShadow = true;
            lantern.add(glass);
            
            // Metal frame
            const frame = new THREE.LineSegments(
                new THREE.EdgesGeometry(new THREE.CylinderGeometry(0.61, 0.61, 1.51, 16)),
                new THREE.LineBasicMaterial({ color: 0x8B4513 })
            );
            frame.position.y = 0.75;
            lantern.add(frame);
            
            // Light source
            const light = new THREE.PointLight(0xFFA500, 2, 5);
            light.position.y = 0.75;
            lantern.add(light);
            
            // Top decoration
            const top = new THREE.Mesh(
                new THREE.CylinderGeometry(0.65, 0.65, 0.3, 16),
                new THREE.MeshStandardMaterial({ color: 0x8B4513, metalness: 0.9 })
            );
            top.position.y = 1.5;
            lantern.add(top);
            
            // Hook and chain
            const hook = new THREE.Mesh(
                new THREE.TorusGeometry(0.15, 0.03, 8, 16),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            hook.position.y = 2;
            hook.rotation.x = Math.PI/2;
            lantern.add(hook);
            
            lantern.position.set(x, y, z);
            return lantern;
        }
        
        // Add lanterns around mosque
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const radius = 10 + Math.random() * 3;
            const lantern = createLantern(
                Math.cos(angle) * radius,
                5 + Math.random() * 2,
                Math.sin(angle) * radius
            );
            scene.add(lantern);
        }
        
        updateProgress(70, "Adding people...");
        
        // Human characters with simple animations
        class HumanCharacter {
            constructor(x, z) {
                this.group = new THREE.Group();
                this.animationState = 'walking';
                this.animationTime = 0;
                this.targetPosition = new THREE.Vector3(
                    x + (Math.random() - 0.5) * 10,
                    0,
                    z + (Math.random() - 0.5) * 10
                );
                this.speed = 0.02 + Math.random() * 0.02;
                
                // Body parts
                this.body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 1, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4682B4 })
                );
                this.body.position.y = 0.5;
                this.group.add(this.body);
                
                // Head
                this.head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xF5DEB3 })
                );
                this.head.position.y = 1.25;
                this.group.add(this.head);
                
                // Arms
                this.leftArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4682B4 })
                );
                this.leftArm.position.set(-0.35, 0.8, 0);
                this.leftArm.rotation.z = Math.PI/2;
                this.group.add(this.leftArm);
                
                this.rightArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4682B4 })
                );
                this.rightArm.position.set(0.35, 0.8, 0);
                this.rightArm.rotation.z = -Math.PI/2;
                this.group.add(this.rightArm);
                
                // Legs
                this.leftLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x2F4F4F })
                );
                this.leftLeg.position.set(-0.15, -0.4, 0);
                this.group.add(this.leftLeg);
                
                this.rightLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x2F4F4F })
                );
                this.rightLeg.position.set(0.15, -0.4, 0);
                this.group.add(this.rightLeg);
                
                this.group.position.set(x, 0, z);
                this.group.rotation.y = Math.random() * Math.PI * 2;
            }
            
            update(deltaTime) {
                this.animationTime += deltaTime;
                
                switch(this.animationState) {
                    case 'walking':
                        // Move toward target
                        const direction = new THREE.Vector3().subVectors(
                            this.targetPosition, 
                            this.group.position
                        ).normalize();
                        
                        this.group.position.add(direction.multiplyScalar(this.speed));
                        this.group.rotation.y = Math.atan2(direction.x, direction.z);
                        
                        // Walking animation
                        this.leftArm.rotation.x = Math.sin(this.animationTime * 5) * 0.5;
                        this.rightArm.rotation.x = Math.sin(this.animationTime * 5 + Math.PI) * 0.5;
                        this.leftLeg.rotation.x = Math.sin(this.animationTime * 5 + Math.PI) * 0.3;
                        this.rightLeg.rotation.x = Math.sin(this.animationTime * 5) * 0.3;
                        
                        // Check if reached target
                        if (this.group.position.distanceTo(this.targetPosition) < 0.5) {
                            this.animationState = Math.random() > 0.7 ? 'praying' : 'talking';
                            this.animationTime = 0;
                            
                            if (this.animationState === 'praying') {
                                // Face mosque
                                const mosqueDirection = new THREE.Vector3().subVectors(
                                    new THREE.Vector3(0, 0, 0),
                                    this.group.position
                                ).normalize();
                                this.group.rotation.y = Math.atan2(mosqueDirection.x, mosqueDirection.z);
                            }
                        }
                        break;
                        
                    case 'praying':
                        // Prayer animation
                        this.leftArm.rotation.x = -Math.PI/2 + Math.sin(this.animationTime * 2) * 0.1;
                        this.rightArm.rotation.x = -Math.PI/2;
                        this.body.rotation.z = Math.sin(this.animationTime) * 0.1;
                        
                        if (this.animationTime > 3 + Math.random() * 4) {
                            this.animationState = 'walking';
                            this.targetPosition = new THREE.Vector3(
                                this.group.position.x + (Math.random() - 0.5) * 10,
                                0,
                                this.group.position.z + (Math.random() - 0.5) * 10
                            );
                        }
                        break;
                        
                    case 'talking':
                        // Talking animation
                        this.leftArm.rotation.x = Math.PI/4 + Math.sin(this.animationTime * 3) * 0.2;
                        this.rightArm.rotation.x = Math.PI/4 + Math.cos(this.animationTime * 3.5) * 0.2;
                        
                        if (this.animationTime > 2 + Math.random() * 3) {
                            this.animationState = 'walking';
                            this.targetPosition = new THREE.Vector3(
                                this.group.position.x + (Math.random() - 0.5) * 10,
                                0,
                                this.group.position.z + (Math.random() - 0.5) * 10
                            );
                        }
                        break;
                }
            }
        }
        
        // Create human characters
        const humans = [];
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 5 + Math.random() * 8;
            const human = new HumanCharacter(
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            );
            scene.add(human.group);
            humans.push(human);
        }
        
        updateProgress(90, "Final touches...");
        
        // Ground with texture
        const groundGeometry = new THREE.CircleGeometry(100, 64);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d5a3d,
            roughness: 0.8,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Decorative elements
        function createPrayerMat(x, z) {
            const mat = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 0.8),
                new THREE.MeshStandardMaterial({ 
                    color: 0x006400,
                    side: THREE.DoubleSide
                })
            );
            mat.rotation.x = -Math.PI / 2;
            mat.position.set(x, 0.01, z);
            return mat;
        }
        
        // Add prayer mats
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const distance = 6 + Math.random();
            const mat = createPrayerMat(
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            );
            scene.add(mat);
        }
        
        // Completion
        updateProgress(100, "Ready!");
        setTimeout(() => {
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
            }, 1000);
        }, 500);
        
        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Update moon rotation
            moon.rotation.y += delta * 0.05;
            
            // Update humans
            humans.forEach(human => human.update(delta));
            
            // Update controls
            controls.update();
            
            // Render with post-processing
            composer.render();
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
